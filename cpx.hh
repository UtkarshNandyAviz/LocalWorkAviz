/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* This code was generated by avrogencpp 1.11.3. Do not edit.*/

#ifndef CPX_HH_2655653064_H
#define CPX_HH_2655653064_H


#include <sstream>
#include "boost/any.hpp"
#include "avro/Specific.hh"
#include "avro/Encoder.hh"
#include "avro/Decoder.hh"

enum class IpType: unsigned {
    IPTYPE_IPV4,
    IPTYPE_IPV6,
    IPTYPE_INVALID,
};

enum class ProtType: unsigned {
    PROTTYPE_ICMP,
    PROTTYPE_TCP,
    PROTTYPE_UNSUPPORTED,
};

enum class SessionState: unsigned {
    SESSION_STATE_RUNNING,
    SESSION_STATE_STOPPING,
    SESSION_STATE_STOPPED,
};

struct clientparams {
    std::string agent_ip;
    std::string dest_ip;
    IpType ipType;
    ProtType protType;
    int32_t interval;
    int32_t id;
    SessionState state;
    int32_t port;
    clientparams() :
        agent_ip(std::string()),
        dest_ip(std::string()),
        ipType(IpType()),
        protType(ProtType()),
        interval(int32_t()),
        id(int32_t()),
        state(SessionState()),
        port(int32_t())
        { }
};


namespace avro {
template<> struct codec_traits<IpType> {
    static void encode(Encoder& e, IpType v) {
        if (v > IpType::IPTYPE_INVALID)
        {
            std::ostringstream error;
            error << "enum value " << static_cast<unsigned>(v) << " is out of bound for c::IpType and cannot be encoded";
            throw avro::Exception(error.str());
        }
        e.encodeEnum(static_cast<size_t>(v));
    }
    static void decode(Decoder& d, IpType& v) {
        size_t index = d.decodeEnum();
        if (index > static_cast<size_t>(IpType::IPTYPE_INVALID))
        {
            std::ostringstream error;
            error << "enum value " << index << " is out of bound for c::IpType and cannot be decoded";
            throw avro::Exception(error.str());
        }
        v = static_cast<IpType>(index);
    }
};

template<> struct codec_traits<ProtType> {
    static void encode(Encoder& e, ProtType v) {
        if (v > ProtType::PROTTYPE_UNSUPPORTED)
        {
            std::ostringstream error;
            error << "enum value " << static_cast<unsigned>(v) << " is out of bound for c::ProtType and cannot be encoded";
            throw avro::Exception(error.str());
        }
        e.encodeEnum(static_cast<size_t>(v));
    }
    static void decode(Decoder& d, ProtType& v) {
        size_t index = d.decodeEnum();
        if (index > static_cast<size_t>(ProtType::PROTTYPE_UNSUPPORTED))
        {
            std::ostringstream error;
            error << "enum value " << index << " is out of bound for c::ProtType and cannot be decoded";
            throw avro::Exception(error.str());
        }
        v = static_cast<ProtType>(index);
    }
};

template<> struct codec_traits<SessionState> {
    static void encode(Encoder& e, SessionState v) {
        if (v > SessionState::SESSION_STATE_STOPPED)
        {
            std::ostringstream error;
            error << "enum value " << static_cast<unsigned>(v) << " is out of bound for c::SessionState and cannot be encoded";
            throw avro::Exception(error.str());
        }
        e.encodeEnum(static_cast<size_t>(v));
    }
    static void decode(Decoder& d, SessionState& v) {
        size_t index = d.decodeEnum();
        if (index > static_cast<size_t>(SessionState::SESSION_STATE_STOPPED))
        {
            std::ostringstream error;
            error << "enum value " << index << " is out of bound for c::SessionState and cannot be decoded";
            throw avro::Exception(error.str());
        }
        v = static_cast<SessionState>(index);
    }
};

template<> struct codec_traits<clientparams> {
    static void encode(Encoder& e, const clientparams& v) {
        avro::encode(e, v.agent_ip);
        avro::encode(e, v.dest_ip);
        avro::encode(e, v.ipType);
        avro::encode(e, v.protType);
        avro::encode(e, v.interval);
        avro::encode(e, v.id);
        avro::encode(e, v.state);
        avro::encode(e, v.port);
    }
    static void decode(Decoder& d, clientparams& v) {
        if (avro::ResolvingDecoder *rd =
            dynamic_cast<avro::ResolvingDecoder *>(&d)) {
            const std::vector<size_t> fo = rd->fieldOrder();
            for (std::vector<size_t>::const_iterator it = fo.begin();
                it != fo.end(); ++it) {
                switch (*it) {
                case 0:
                    avro::decode(d, v.agent_ip);
                    break;
                case 1:
                    avro::decode(d, v.dest_ip);
                    break;
                case 2:
                    avro::decode(d, v.ipType);
                    break;
                case 3:
                    avro::decode(d, v.protType);
                    break;
                case 4:
                    avro::decode(d, v.interval);
                    break;
                case 5:
                    avro::decode(d, v.id);
                    break;
                case 6:
                    avro::decode(d, v.state);
                    break;
                case 7:
                    avro::decode(d, v.port);
                    break;
                default:
                    break;
                }
            }
        } else {
            avro::decode(d, v.agent_ip);
            avro::decode(d, v.dest_ip);
            avro::decode(d, v.ipType);
            avro::decode(d, v.protType);
            avro::decode(d, v.interval);
            avro::decode(d, v.id);
            avro::decode(d, v.state);
            avro::decode(d, v.port);
        }
    }
};

}
#endif
